   0x401106 <+18>: // read 6 numbers from mystring and put them on the stack

                   // the 6 numbers ought to be different and between 1..6
   0x401114 <+32>:	for (i=0; i<6; i++) {
   0x40111e <+42>:	    assert (M[rsp + 4 * i] <= 6)
   0x401132 <+62>:	    for (j = i; j <= 5; j++) {
   0x40113b <+71>:	        assert (M[rsp + 4 * i] != M[rsp + 4 * j])
                        }
   0x401151 <+93>:	}

                    // each number will become 7 - number (so still numbers 1..6)
   0x401158 <+100>:	for (i=0; i<6; i++) {
   0x401164 <+112>:	    M[rsp + 4 * i] = 7 - M[rsp + 4 * i]
                    }

                    // sp +32, +40, ... +72 filled with memmory addresses based
                    // on the value of mynumber n in sp +0, +4, ... as such
                    // n=2 | addr = 0x6032e0 | value 168 | 7- = 5
                    // n=1 | addr = 0x6032d0 | value 332 | 7- = 6
                    // n=6 | addr = 0x603320 | value 443 | 7- = 1
                    // n=5 | addr = 0x603310 | value 477 | 7- = 2
                    // n=4 | addr = 0x603300 | value 691 | 7- = 3
                    // n=3 | addr = 0x6032f0 | value 924 | 7- = 4             
                        
                    for (i = 0; i < 6; i++;) {
   0x401197 <+163>:	    n = M[rsp + 4 * i]   // my (modified) numbers
   0x401183 <+143>:	    x = $0x6032d0
   0x40119a <+166>:	    if (n > 1) {
                            for (j=1; j<n; j++)
   0x401176 <+130>:	            x = M[x + 8]
                        }
   0x401188 <+148>:	    M[32 + rsp + 8 * i] = x
   0x401191 <+157>:	} 

                    // M[addr + 8] = addr per i vari addr di sopra
   0x4011ba <+198>:	x = M[32 + rsp]                e.g., x = 0x6032e0
                    for (i = 0; i < 5; i++) {
   0x4011bd <+201>:	    y = M[40 + rsp + 8 * i]    e.g., y = 0x6033d0 | 0x603320
   0x4011c0 <+204>:	    M[8 + x] = y               e.g., M[0x6033e8] = 0x6033d0 | 
                                                         M[0x6033d8] = 0x603320
   0x4011cd <+217>:	    x = y                      e.g., x = 0x6033d0 | 0x603320
   0x4011d0 <+220>:	}

   0x4011d2 <+222>:	M[8 + y] = 0

                    x = 32 +rsp
                    for (i=5; i>0; i--) { 
   0x4011df <+235>:	    y = M[8 + x]                e.g.   y = 0x6032d0
   0x4011e3 <+239>:	    y = M[y]   // 64 to 32 bits e.g.   y = 332
   0x4011e5 <+241>:	    assert ((M[x] >= y)         e.g. M[32+rsp] >= 
                                                         M[603320]
   0x4011ee <+250>:	    x = M[8 + x]
                    }
   0x401203 <+271>:	retq   
